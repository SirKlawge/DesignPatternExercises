Notes from Head First Design Patterns:
    
    When you're designing your program, try to isolate the non-changing parts of the program from those that do 
    change.
    
    "Program to an interface" really means "Program to a supertype".
    
    When you make your compile time declarations, the left side of the assignment operator, try to always refer to 
    the interface/abstract class type rather than that of a concrete class.
    
    So let's say that you have an Animal superclass with a Dog and Cat subclass.  We know that both Dogs and Cats make 
    sounds, so rather than having the client do something like
        Animal d = new Dog();
        d.bark();
        
    which locks you into the particular implementation found in the Dog class, do something more general like
        Animal animal = new Dog();
        animal.makeSound();
        
    Where makeSound is an abstract method in Animal's interface.  This is another example of programming to an interface.
    Both Dog and Cat class override and provide implementation for makeSound().
    
    We can make this even better by not even using the new operator in the client:
        Animal a = getAnimal();
        a.makeSound();
        
    Where there's some other class that determines which runtime object a should refer to.
    
    Rather than thinking of the duck's behaviors as a set of bahaviors, think of them as a family of algorithms.
    
    Design Principle: favor composition over inheritance.  This gives you more flexibilty.
    
    The Duck example is an implementation of the Strategy Pattern.
    
    Strategy Pattern:
        defines a family of algorithms, encapsulates each of them, and makes them interchangable.  This lets the 
        algorithm vary independently from clients that use it.
        
    To be clear, the family of algorithms in the Duck example are FlyBehavior and QuackBahavior, and the concrete 
    classes that implemented these interfaces are the specific, individual algorithms. 
    
    
    Observer Pattern:
        When something changes, notify observers.
        
        The Weather-O-Rama has three components:
            The weather station that gathers weather data.
            The weather data object that tracks data coming from the weather station and updates displays
            The displays that shows the users the current weather.
            
            The three different display elements that we have to develop are:
                Current conditions (temp, humidity, pressure)
                Weather Statistics
                a simple forecast
                
            We want to make this expandable so that other developers can create new custom displays.
            
            If we notify our displays by referencing them specifically, then we're coding to implementation.  Which
            means that if we want to add or change a display, we have to change the code in the meansurementsChanged()
            method.
            
        
        The book uses the language of Subject/Observer.  The subject is the observable.  Remember the way you 
        implemented this in MVC: the View held an instance of the Model, and the view then called 
        model.addObserver(this);
        
        Formal definition of Observable pattern: a one-to-many dependency between objects such that when one 
        object changes state, all of its dependents are notified and updated automatically.
        
        Participants:
            
            Subject (Interface) - defines the interfaace through which Observers can subscribe or unsubscribe. Also 
            defines an notifyObservers method through which the Observable notifies Observers.
            
            ConcreteSubject - the Observable class that sends out notifications.
            
            Observer (interface) - defines the update method that will ultimately allow concrete classes to respond
            to notifications.
            
            ConcreteObserver - responds to notifications from Subjects via the update method.
            
        Sure, the subscribers enter into a relationship of dependence upon the Subject, but this is a loose coupling.
        They don't need to know implementation details about the Subject.  Really, they only ever see the output as 
        the Subject wishes to send.  And the Subject knows nothing about its Observers other than that they are 
        Observers.
        
        As a design principle, we should strive for loosely coupled designs between objects that interact.
        
        Java's swing library has listeners that its components can use to respond to various types of events that 
		occur on Swing components.
		
		The Observer/Observable classes in Java started to be phased out as of Java 9.
		People prefered to implement their own Observer/OBservable interfaces since they were able to customize 
		them.
		
		You could modify the Observer/Observable pattern so that rather than the Subject pushing it's updates to 
		the observers in a way that it chooses, you could have the Observers pull the information that they choose
		(so long as the Subject makes it available).  To do this:
			1) Have the subject provide the relevant getter methods
			2) Change the Subject's notifyObservers() to traverse the list of Observers and call update() but 
			with no parameters
			3) Change the observer interface so that update() method has no paramters.  Make the same change for 
			all concrete observers.
			4) Since each concrete observer holds a reference to the Subject, use the Subject's getters inside
			the update method to gather only the data that each concrete observer needs.
		
	
	THe Decorator Pattern:
		
		Decorator pattern will allow us to give objects new responsibilities and functionality without having to 
		change their unerlying classes.  We do this by making the object a component of a wrapper class.
		
		Let's say you have a coffee shop that offers a variety of beverages.  You could have an abstract Beverage
		class that other concrete beverages inherit, each of which overrides the abstract cost method.
		What results is a "class explosion", a rapid increase in the number of classes, as the menu grows.
		
		Design Principle: classes should be cloesd to change, but open to extension. 
		
		Instead of using inheritance, which locks its subclasses into whatever functionality the superclass 
		provides, we're gonna start with basic objects and wrap them into more complex objects.
		
			Start with a DarkRoast object.
			Decorate it with a Whip object
			Decorate it with a Mocha object
			Call the cost() method and rely on delegation (strategy?) to add up the condiments. (Maybe the costs
			are included in the Whip and Mocha wrappers)
			
		So all of the above classes, DarkRoast, Whip, Mocha, have a cost() method.  So how do we get these methods 
		to properly calculate the cost?  Answer: call cost() on the outermost decorator, and it'll delegate 
		computing the cost to the objects it decorates.
		
		Decorators have the same supertype as the objects they decorate.
		
		We can pass around a decorated object in place of original warpped object.
		
		Formal def of Decorator Pattern:
			attaches addition responsibilities to an object dynamically.
			
		Participants:
			AbstractComponent - the superclass that the concrete compoments and their wrappers/decorators 
			inherit
			
			ConcreteComponent - the object that we're going to dynamically add new behaviors to.
			
			Decorator - each decorator Has-A component that it wraps, that is, has it as a field.  This class
			is declared abstract, and the Component that it takes as a field is declared as the AbstractComponent 
			type described above: this way it can wrap any ConcreteComponent.
			
			ConcreteDecorator - inherit the Decorator, and it takes a concrete component and wraps it.
			
		The decorators inherit the same class as the beverages.  The primary reason for doing this isnt for the 
		sake of inheriting behavior, but for type matching: so that the decorators can be treated the same way in
		some respect as the things they decorate.
		
		The objects acquire new behavior not through inheritence, but through composition.
		
		Relying on inheritence makes it so behavor is determined statically at compile time.
		
		As you learned in class, Java's I/O classes is an example of the Decorator pattern.
		
		One of the downsides of the Decorator pattern is that you end up with a large menu of small classes, or 
		decorators, which can be overwhelming to developers.  