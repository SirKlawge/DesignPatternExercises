Notes from Head First Design Patterns:
    
    When you're designing your program, try to isolate the non-changing parts of the program from those that do 
    change.
    
    "Program to an interface" really means "Program to a supertype".
    
    When you make your compile time declarations, the left side of the assignment operator, try to always refer to 
    the interface/abstract class type rather than that of a concrete class.
    
    So let's say that you have an Animal superclass with a Dog and Cat subclass.  We know that both Dogs and Cats make 
    sounds, so rather than having the client do something like
        Animal d = new Dog();
        d.bark();
        
    which locks you into the particular implementation found in the Dog class, do something more general like
        Animal animal = new Dog();
        animal.makeSound();
        
    Where makeSound is an abstract method in Animal's interface.  This is another example of programming to an interface.
    Both Dog and Cat class override and provide implementation for makeSound().
    
    We can make this even better by not even using the new operator in the client:
        Animal a = getAnimal();
        a.makeSound();
        
    Where there's some other class that determines which runtime object a should refer to.
    
    Rather than thinking of the duck's behaviors as a set of bahaviors, think of them as a family of algorithms.
    
    Design Principle: favor composition over inheritance.  This gives you more flexibilty.
    
    The Duck example is an implementation of the Strategy Pattern.
    
    Strategy Pattern:
        defines a family of algorithms, encapsulates each of them, and makes them interchangable.  This lets the 
        algorithm vary independently from clients that use it.
        
    To be clear, the family of algorithms in the Duck example are FlyBehavior and QuackBahavior, and the concrete 
    classes that implemented these interfaces are the specific, individual algorithms. 
    
    
    Observer Pattern:
        When something changes, notify observers.
        
        The Weather-O-Rama has three components:
            The weather station that gathers weather data.
            The weather data object that tracks data coming from the weather station and updates displays
            The displays that shows the users the current weather.
            
            The three different display elements that we have to develop are:
                Current conditions (temp, humidity, pressure)
                Weather Statistics
                a simple forecast
                
            