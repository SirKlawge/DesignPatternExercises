Notes from Head First Design Patterns:
    
    When you're designing your program, try to isolate the non-changing parts of the program from those that do 
    change.
    
    "Program to an interface" really means "Program to a supertype".
    
    When you make your compile time declarations, the left side of the assignment operator, try to always refer to 
    the interface/abstract class type rather than that of a concrete class.
    
    So let's say that you have an Animal superclass with a Dog and Cat subclass.  We know that both Dogs and Cats make 
    sounds, so rather than having the client do something like
        Animal d = new Dog();
        d.bark();
        
    which locks you into the particular implementation found in the Dog class, do something more general like
        Animal animal = new Dog();
        animal.makeSound();
        
    Where makeSound is an abstract method in Animal's interface.  This is another example of programming to an interface.
    Both Dog and Cat class override and provide implementation for makeSound().
    
    We can make this even better by not even using the new operator in the client:
        Animal a = getAnimal();
        a.makeSound();
        
    Where there's some other class that determines which runtime object a should refer to.
    
    Rather than thinking of the duck's behaviors as a set of bahaviors, think of them as a family of algorithms.
    
    Design Principle: favor composition over inheritance.  This gives you more flexibilty.
    
    The Duck example is an implementation of the Strategy Pattern.
    
    Strategy Pattern:
        defines a family of algorithms, encapsulates each of them, and makes them interchangable.  This lets the 
        algorithm vary independently from clients that use it.
        
    To be clear, the family of algorithms in the Duck example are FlyBehavior and QuackBahavior, and the concrete 
    classes that implemented these interfaces are the specific, individual algorithms. 
    
    
    Observer Pattern:
        When something changes, notify observers.
        
        The Weather-O-Rama has three components:
            The weather station that gathers weather data.
            The weather data object that tracks data coming from the weather station and updates displays
            The displays that shows the users the current weather.
            
            The three different display elements that we have to develop are:
                Current conditions (temp, humidity, pressure)
                Weather Statistics
                a simple forecast
                
            We want to make this expandable so that other developers can create new custom displays.
            
            If we notify our displays by referencing them specifically, then we're coding to implementation.  Which
            means that if we want to add or change a display, we have to change the code in the meansurementsChanged()
            method.
            
        
        The book uses the language of Subject/Observer.  The subject is the observable.  Remember the way you 
        implemented this in MVC: the View held an instance of the Model, and the view then called 
        model.addObserver(this);
        
        Formal definition of Observable pattern: a one-to-many dependency between objects such that when one 
        object changes state, all of its dependents are notified and updated automatically.
        
        Participants:
            
            Subject (Interface) - defines the interfaace through which Observers can subscribe or unsubscribe. Also 
            defines an notifyObservers method through which the Observable notifies Observers.
            
            ConcreteSubject - the Observable class that sends out notifications.
            
            Observer (interface) - defines the update method that will ultimately allow concrete classes to respond
            to notifications.
            
            ConcreteObserver - responds to notifications from Subjects via the update method.
            
        Sure, the subscribers enter into a relationship of dependence upon the Subject, but this is a loose coupling.
        They don't need to know implementation details about the Subject.  Really, they only ever see the output as 
        the Subject wishes to send.  And the Subject knows nothing about its Observers other than that they are 
        Observers.
        
        As a design principle, we should strive for loosely coupled designs between objects that interact.
        
        